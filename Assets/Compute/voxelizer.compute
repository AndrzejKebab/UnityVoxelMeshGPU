#pragma kernel CSMain

#define CHUNK_SIZE 80

struct Vertex {
    float3 position;
    float2 texcoord;
    float3 normal;
};

struct GeometryData {
    uint vertexCount;
    uint indexCount;
};

struct ChunkFeedback {
    uint vertexOffset;
    uint vertexCount;
    uint indexOffset;
    uint indexCount;
};

RWStructuredBuffer<Vertex> uVertices;
RWStructuredBuffer<uint> uIndices;
StructuredBuffer<int> uVoxels;
// StructuredBuffer<GeometryData> uFeedback;
StructuredBuffer<ChunkFeedback> uChunkFeedback;

groupshared uint sVertexOffset;
groupshared uint sVertexCount;
groupshared uint sIndexOffset;
groupshared uint sIndexCount;
groupshared uint sChunkIndex;

uint to1D(uint3 pos) {
    return pos.x + CHUNK_SIZE * (pos.y + CHUNK_SIZE * pos.z);
}

int to1D(int3 pos) {
    return pos.x + CHUNK_SIZE * (pos.y + CHUNK_SIZE * pos.z);
}

uint3 to3D(uint idx) {
    uint x = idx % CHUNK_SIZE;
    uint y = (idx / CHUNK_SIZE) % CHUNK_SIZE;
    uint z = idx / (CHUNK_SIZE * CHUNK_SIZE);

    // uint z = idx / (CHUNK_SIZE * CHUNK_SIZE);
    // idx -= (z * CHUNK_SIZE * CHUNK_SIZE);
    // uint y = idx / CHUNK_SIZE;
    // uint x = idx % CHUNK_SIZE;
    return uint3(x, y, z);
}

bool hasVoxel(int3 coord) {
    if (coord.x < 0 || coord.x >= CHUNK_SIZE || 
        coord.y < 0 || coord.y >= CHUNK_SIZE ||
        coord.z < 0 || coord.z >= CHUNK_SIZE) {
        return false;
    }

    int idx = to1D(coord);
    return uVoxels[idx] > 0;
}

void setVertex(out Vertex vertex, in float3 position, in float2 texcoord, in float3 normal) {
    vertex.position = position;
    vertex.texcoord = texcoord;
    vertex.normal = normal;
}

[numthreads(8, 8, 8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x == 0 && id.y == 0 && id.z == 0) {
        // sChunkIndex = uChunkIndices.data[gl_WorkGroupID.x + 10 * (gl_WorkGroupID.y + 10 * gl_WorkGroupID.z)];
        sChunkIndex = id.x + 10 * (id.y + 10 * id.z);
        sVertexOffset = uChunkFeedback[sChunkIndex].vertexOffset;
        sIndexOffset = uChunkFeedback[sChunkIndex].indexOffset;
        sVertexCount = uChunkFeedback[sChunkIndex].vertexCount;
        sIndexCount = uChunkFeedback[sChunkIndex].indexCount;
    }

    GroupMemoryBarrierWithGroupSync();

    uint globalVoxelIndex = to1D(id);

    if (uVoxels[globalVoxelIndex] > 0)
    {
        int3 coord = int3(id);
        float3 position = float3(coord);

        uint vertexOffset, indexOffset;

        // +X
        if (!hasVoxel(coord + int3(1, 0, 0))) {
            InterlockedAdd(sVertexOffset, 4, vertexOffset);
            InterlockedAdd(sIndexOffset, 6, indexOffset);

            setVertex(uVertices[vertexOffset + 0], position + float3(0.5, 0.5, 0.5), float2(0.0, 0.0), float3(1.0, 0.0, 0.0));
            setVertex(uVertices[vertexOffset + 1], position + float3(0.5, -0.5, 0.5), float2(0.0, 1.0), float3(1.0, 0.0, 0.0));
            setVertex(uVertices[vertexOffset + 2], position + float3(0.5, -0.5, -0.5), float2(1.0, 1.0), float3(1.0, 0.0, 0.0));
            setVertex(uVertices[vertexOffset + 3], position + float3(0.5, 0.5, -0.5), float2(1.0, 0.0), float3(1.0, 0.0, 0.0));

            uIndices[indexOffset + 0] = vertexOffset;
            uIndices[indexOffset + 1] = vertexOffset + 1;
            uIndices[indexOffset + 2] = vertexOffset + 2;

            uIndices[indexOffset + 3] = vertexOffset + 2;
            uIndices[indexOffset + 4] = vertexOffset + 3;
            uIndices[indexOffset + 5] = vertexOffset;
        }

        // -X
        if (!hasVoxel(coord + int3(-1, 0, 0))) {
            InterlockedAdd(sVertexOffset, 4, vertexOffset);
            InterlockedAdd(sIndexOffset, 6, indexOffset);

            setVertex(uVertices[vertexOffset + 0], position + float3(-0.5, 0.5, -0.5), float2(0.0, 0.0), float3(-1.0, 0.0, 0.0));
            setVertex(uVertices[vertexOffset + 1], position + float3(-0.5, -0.5, -0.5), float2(0.0, 1.0), float3(-1.0, 0.0, 0.0));
            setVertex(uVertices[vertexOffset + 2], position + float3(-0.5, -0.5, 0.5), float2(1.0, 1.0), float3(-1.0, 0.0, 0.0));
            setVertex(uVertices[vertexOffset + 3], position + float3(-0.5, 0.5, 0.5), float2(1.0, 0.0), float3(-1.0, 0.0, 0.0));

            uIndices[indexOffset + 0] = vertexOffset;
            uIndices[indexOffset + 1] = vertexOffset + 1;
            uIndices[indexOffset + 2] = vertexOffset + 2;

            uIndices[indexOffset + 3] = vertexOffset + 2;
            uIndices[indexOffset + 4] = vertexOffset + 3;
            uIndices[indexOffset + 5] = vertexOffset;
        }

        // +Y
        if (!hasVoxel(coord + int3(0, 1, 0))) {
            InterlockedAdd(sVertexOffset, 4, vertexOffset);
            InterlockedAdd(sIndexOffset, 6, indexOffset);

            setVertex(uVertices[vertexOffset + 0], position + float3(-0.5, 0.5, -0.5), float2(0.0, 0.0), float3(0.0, 1.0, 0.0));
            setVertex(uVertices[vertexOffset + 1], position + float3(-0.5, 0.5, 0.5), float2(0.0, 1.0), float3(0.0, 1.0, 0.0));
            setVertex(uVertices[vertexOffset + 2], position + float3(0.5, 0.5, 0.5), float2(1.0, 1.0), float3(0.0, 1.0, 0.0));
            setVertex(uVertices[vertexOffset + 3], position + float3(0.5, 0.5, -0.5), float2(1.0, 0.0), float3(0.0, 1.0, 0.0));

            uIndices[indexOffset + 0] = vertexOffset;
            uIndices[indexOffset + 1] = vertexOffset + 1;
            uIndices[indexOffset + 2] = vertexOffset + 2;

            uIndices[indexOffset + 3] = vertexOffset + 2;
            uIndices[indexOffset + 4] = vertexOffset + 3;
            uIndices[indexOffset + 5] = vertexOffset;
        }

        // -Y
        if (!hasVoxel(coord + int3(0, -1, 0))) {
            InterlockedAdd(sVertexOffset, 4, vertexOffset);
            InterlockedAdd(sIndexOffset, 6, indexOffset);

            setVertex(uVertices[vertexOffset + 0], position + float3(-0.5, -0.5, 0.5), float2(0.0, 0.0), float3(0.0, -1.0, 0.0));
            setVertex(uVertices[vertexOffset + 1], position + float3(-0.5, -0.5, -0.5), float2(0.0, 1.0), float3(0.0, -1.0, 0.0));
            setVertex(uVertices[vertexOffset + 2], position + float3(0.5, -0.5, -0.5), float2(1.0, 1.0), float3(0.0, -1.0, 0.0));
            setVertex(uVertices[vertexOffset + 3], position + float3(0.5, -0.5, 0.5), float2(1.0, 0.0), float3(0.0, -1.0, 0.0));

            uIndices[indexOffset + 0] = vertexOffset;
            uIndices[indexOffset + 1] = vertexOffset + 1;
            uIndices[indexOffset + 2] = vertexOffset + 2;

            uIndices[indexOffset + 3] = vertexOffset + 2;
            uIndices[indexOffset + 4] = vertexOffset + 3;
            uIndices[indexOffset + 5] = vertexOffset;
        }

        // +Z
        if (!hasVoxel(coord + int3(0, 0, 1))) {
            InterlockedAdd(sVertexOffset, 4, vertexOffset);
            InterlockedAdd(sIndexOffset, 6, indexOffset);

            setVertex(uVertices[vertexOffset + 0], position + float3(-0.5, 0.5, 0.5), float2(0.0, 0.0), float3(0.0, 0.0, 1.0));
            setVertex(uVertices[vertexOffset + 1], position + float3(-0.5, -0.5, 0.5), float2(0.0, 1.0), float3(0.0, 0.0, 1.0));
            setVertex(uVertices[vertexOffset + 2], position + float3(0.5, -0.5, 0.5), float2(1.0, 1.0), float3(0.0, 0.0, 1.0));
            setVertex(uVertices[vertexOffset + 3], position + float3(0.5, 0.5, 0.5), float2(1.0, 0.0), float3(0.0, 0.0, 1.0));

            uIndices[indexOffset + 0] = vertexOffset;
            uIndices[indexOffset + 1] = vertexOffset + 1;
            uIndices[indexOffset + 2] = vertexOffset + 2;

            uIndices[indexOffset + 3] = vertexOffset + 2;
            uIndices[indexOffset + 4] = vertexOffset + 3;
            uIndices[indexOffset + 5] = vertexOffset;
        }

        // -Z
        if (!hasVoxel(coord + int3(0, 0, -1))) {
            InterlockedAdd(sVertexOffset, 4, vertexOffset);
            InterlockedAdd(sIndexOffset, 6, indexOffset);

            setVertex(uVertices[vertexOffset + 0], position + float3(0.5, 0.5, -0.5), float2(0.0, 0.0), float3(0.0, 0.0, -1.0));
            setVertex(uVertices[vertexOffset + 1], position + float3(0.5, -0.5, -0.5), float2(0.0, 1.0), float3(0.0, 0.0, -1.0));
            setVertex(uVertices[vertexOffset + 2], position + float3(-0.5, -0.5, -0.5), float2(1.0, 1.0), float3(0.0, 0.0, -1.0));
            setVertex(uVertices[vertexOffset + 3], position + float3(-0.5, 0.5, -0.5), float2(1.0, 0.0), float3(0.0, 0.0, -1.0));

            uIndices[indexOffset + 0] = vertexOffset;
            uIndices[indexOffset + 1] = vertexOffset + 1;
            uIndices[indexOffset + 2] = vertexOffset + 2;

            uIndices[indexOffset + 3] = vertexOffset + 2;
            uIndices[indexOffset + 4] = vertexOffset + 3;
            uIndices[indexOffset + 5] = vertexOffset;
        }
    }
}